/*
Copyright 2011 Opera Software ASA

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package com.opera.core.systems;

import com.opera.core.systems.common.lang.OperaStrings;

import org.ini4j.Ini;
import org.ini4j.Profile;
import org.openqa.selenium.WebDriverException;
import org.openqa.selenium.io.TemporaryFilesystem;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Map;

/**
 * Interface for reading preferences from the Opera web browser.  This object represents the browser
 * preferences found in <code>opera:config</code> or in the <code>opera.ini</code> file.
 * 
 * Opera preferences are stored in INI format, meaning it's a one level hierarchical model key/value
 * storage.
 * 
 * @see OperaProfile
 */

public class OperaPreferences {

  private Collection<OperaPreference> preferences = new LinkedHashSet<OperaPreference>();

  /**
   * Constructs a new, empty representation of Opera's preferences.
   */
  public OperaPreferences() {  
  }

  /**
   * Constructs a new representation of Opera's preferences based on the given preference file.
   *
   * @param preferenceFile an INI style preference file
   */
  public OperaPreferences(File preferenceFile) {
    //checkArgument(preferenceFile.exists(), "Unknown file: " + preferenceFile.getPath());

    // Due to the sucky nature of Opera's invalid preference files, we are forced to remove the
    // first line of the file.
    //
    // opera.ini looks much like this:
    //
    //   <BOM>
    //   Opera Preferences version 2.1
    //   ; Do not edit this file while Opera is running
    //   ; This file is stored in UTF-8 encoding
    //
    //   [User Prefs]
    //   Language Files Directory=
    //
    //     &c.

    TemporaryFilesystem fs = null;
    File temporaryPreferenceFile;
    Ini ini;
    
    try {
      fs = TemporaryFilesystem.getDefaultTmpFS();
      temporaryPreferenceFile = new File(fs.createTempDir("operadriver", "preferences")
                                         .getAbsolutePath() + File.separator + "opera.ini");

      BufferedReader reader = new BufferedReader(new FileReader(preferenceFile));
      BufferedWriter writer = new BufferedWriter(new FileWriter(temporaryPreferenceFile));
      
      String newLine = System.getProperty("line.separator");
      String currentLine;
      while ((currentLine = reader.readLine()) != null) {
        if (!currentLine.contains("Opera Preferences version")) {
          writer.write(currentLine + newLine);
        }
      }
      
      // Make sure channels are closed so that last line is flushed
      reader.close();
      writer.close();
      
      // Read new preference file
      ini = new Ini(temporaryPreferenceFile);
    } catch (FileNotFoundException e) {
      throw new WebDriverException("Unknown file: " + preferenceFile.getAbsolutePath());
    } catch (IOException e) {
      throw new WebDriverException("Unable to read file: " + preferenceFile.getPath());
    } finally {
      if (fs != null) {
        fs.deleteTemporaryFiles();
      }
    }

    // Add each preference entry.
    for (Map.Entry<String, Profile.Section> section : ini.entrySet()) {
      for (Map.Entry<String, String> entry : section.getValue().entrySet()) {
        // We typically don't care about boolean values, they can be stored as integers.
        String value = (String) entry.getValue();

        if (OperaStrings.isNumeric(value)) {
          set(section.getValue().getName(), entry.getKey(), Integer.valueOf(value));
        } else {
          set(section.getValue().getName(), entry.getKey(), value);
        }
      }
    }
  }

  /**
   * Gets an iterable collection of all preferences in the representation.
   *
   * @return collection of preferences
   */
  public Collection<OperaPreference> getAll() {
    return preferences;
  }

  /**
   * Merges one representation with the given representation.  This will overwrite the preferences
   * in the current representation by the ones in the given one.
   *
   * @param newPreferences the preferences to merge
   */
  public void merge(OperaPreferences newPreferences) {
    for (OperaPreference preference : newPreferences.getAll()) {
      set(preference);
    }
  }

  /**
   * Sets the preference given.  If a previous preference with the same section and key names exist,
   * it will be replaced by the given preference.
   *
   * @param preference the preference to add or update
   */
  public void set(OperaPreference preference) {
    // Does this preference already exist in our collection?
    for (OperaPreference p : preferences) {
      if (p.getSection().equalsIgnoreCase(preference.getSection()) &&
          p.getKey().equalsIgnoreCase(preference.getKey())) {
        // Pref exists, replace with given pref.
        p.setValue(preference.getValue());
        return;
      }
    }

    // Given pref does not exist, add it to collection
    preferences.add(preference);
  }

  public void set(String section, String key, Object value) {
    set(new OperaPreference(section, key, value));
  }

  public OperaPreference get(String section, String key) {
    for (OperaPreference p : preferences) {
      if (p.getSection().equalsIgnoreCase(section) &&
          p.getKey().equalsIgnoreCase(key)) {
        return p;
      }
    }
    return null;
  }

  /**
   * Represents a single preference.
   */
  public static class OperaPreference {

    private String section;
    private String key;
    private Object value;

    public OperaPreference(String section, String key, Object value) {
      this.section = section;
      this.key = key;
      setValue(value);
    }

    public String getSection() {
      return section;
    }

    public String getKey() {
      return key;
    }

    public Object getValue() {
      return value;
    }

    public void setValue(Object value) {
      this.value = value;
    }

  }

}